#!/usr/bin/env python
#
# takes a treelist of all trees that we want to form pathes among them
#
import sys
import os

import pathtrees.pathtrees as pt
import pathtrees.likelihood as like
import pathtrees.phylip as ph
import pathtrees.tree as tree
import pathtrees.MDS as plo

import numpy as np
import time
#import shutil

GTPTREELIST = 'gtptreelist' # a pair of trees formed from the master treelist
GTPTERMINALLIST = 'terminal_output_gtp'  #GTP terminal output
NUMPATHTREES = 10  #number of trees in path
GTP = 'pathtrees/gtp'

def create_treepair(ti,tj):
    f = open(GTPTREELIST,'w')
    f.write(ti.strip())
    f.write("\n")
    f.write(tj.strip())
    f.write('\n')

def run_gtp(gtptreelist,gtpterminallist):
    os.system(f"cd  {GTP}; java -jar gtp.jar -v ../../{gtptreelist} > ../../{gtpterminallist}")
    
def masterpathtrees(treelist): #this is the master treelist
    # loop over treelist:
    allpathtrees = []
    for i,ti in enumerate(treelist):
        for j,tj in enumerate(treelist):
            if j>=i:
                continue
            #form a treelist of the pair
            create_treepair(ti,tj) #this writes into a file GTPTREELIST
            print("run gtp")
            run_gtp(GTPTREELIST, GTPTERMINALLIST)
            mypathtrees = pt.pathtrees(GTPTREELIST, GTPTERMINALLIST, NUMPATHTREES)
            print("LOOP",i,j)
            allpathtrees.extend(mypathtrees)
            #save or manipulate your pathtrees
    return [a.strip() for a in allpathtrees]

def likelihoods(trees,sequences):
    likelihood_values=[]
    for i,newtree in enumerate(trees):
        t = tree.Tree()
        t.myread(newtree,t.root)
        t.insertSequence(t.root,labels,sequences)
        
        #setup mutation model
        # the default for tree is JukesCantor,
        # so these two steps are not really necessary
        Q, basefreqs = like.JukesCantor()
        t.setParameters(Q,basefreqs)
        #calculate likelihood and return it
        t.likelihood()
        likelihood_values.append(t.lnL)
    return likelihood_values

def store_results(outputdir,filename,the_list):
    completename = os. path. join(outputdir, filename)
    np.savetxt (completename, the_list,  fmt='%s')

def myparser():
    import argparse
    parser = argparse.ArgumentParser(description='Create a geodesic path between all trees in the treelist, a treefile and a sequence data file are mandatory, if the the option -r N is used then the treefile (which can be empty) will be augemented with N random trees and the pathtree method is then run on those trees')
    parser.add_argument('STARTTREES', 
                        help='mandatory input file that holds a set of trees in Newick format')
    parser.add_argument('DATAFILE', 
                        help='mandatory input file that holds a sequence data set in PHYLIP format')
    parser.add_argument('-o','--output', dest='outputdir', #action='store_const',
                        #const='outputdir',
                        default='pathtree_outputdir',
                        help='directory that holds the output files')
    parser.add_argument('-v','--verbose', action='store_true',
                        default=None, #const='keep_intermediate',
                        help='Do not remove the intermediate files generated by GPT')
    parser.add_argument('-p','--plot',dest='plotfile',
                        default=None, action='store',
                        help='Create an MDS plot from the generated distances')
    parser.add_argument('-n','--np', '--numpathtrees', dest='NUMPATHTREES',
                        default=10, action='store',type=int,
                        help='Number of trees along the path between two initial trees')
    parser.add_argument('-r','--randomtrees', dest='num_random_trees',
                        default=0, action='store',type=int,
                        help='Generate num_random_trees rooted trees using the sequence data individual names.')

    args = parser.parse_args()
    return args

    
if __name__ == "__main__":
    #DEBUG = True
    args = myparser() # parses the commandline arguments
    start_trees = args.STARTTREES
    datafile = args.DATAFILE
    outputdir = args.outputdir
    keep = args.verbose == True
    num_random_trees = args.num_random_trees
    plotfile = args.plotfile
    if plotfile != None:
        plotfile2 = "contour"+plotfile
    NUMPATHTREES = args.NUMPATHTREES
    os.system(f'mkdir -p {outputdir}')
    #    print(args.plotfile)
    print(args)

    labels, sequences, variable_sites = ph.readData(datafile)
    #print(labels)
    #print(variable_sites)
    #sys.exit()
    if num_random_trees>0:
        totaltreelength = ph.guess_totaltreelength(variable_sites)
        randomtrees = [tree.generate_random_tree(labels, totaltreelength) for _ in range(num_random_trees)]
        #print(randomtrees)
        #sys.exit()
        with open(start_trees,'a') as f:
            for rt in randomtrees:
                print(rt,file=f)
    
    tic = time.perf_counter()
    with open(start_trees,'r') as f:
        StartTrees = [line.strip() for line in f]
    Pathtrees = masterpathtrees(StartTrees)

    Treelist= StartTrees+Pathtrees
    #Treelist = [s.replace('\n', '') for s in trees]
    Likelihoods = likelihoods(Treelist,sequences)
    
    store_results(outputdir,'likelihood',Likelihoods)
    store_results(outputdir,'treelist',Treelist)
    store_results(outputdir,'starttrees',StartTrees)
    store_results(outputdir,'pathtrees',Pathtrees)
    
    toc = time.perf_counter()
    time1 = toc - tic
    #print(50*"=")
    print(f"\nTime of generating pathtrees results = {time1}")

    tic2 = time.perf_counter()
    #if DEBUG:
    newtreelist = os.path.join(outputdir, 'treelist')
    print('Calculate geodesic distance among all pathtrees',file=sys.stderr)
    run_gtp(newtreelist, GTPTERMINALLIST)
    os.system(f'mv pathtrees/gtp/output.txt {outputdir}/')
    if not keep:
        os.system(f'rm {GTPTERMINALLIST}')
        os.system(f'rm {GTPTREELIST}')
    toc2 = time.perf_counter()
    time2 = toc2 - tic2
    print(f"Time of GTP distances of all trees = {time2}")
    if plotfile != None:
        bestlike = plo.best_likelihoods(Likelihoods)
        n = len(Treelist)
        N= len(Pathtrees)
        distancefile = os.path.join(outputdir, 'output.txt')
        distances = plo.read_GTP_distances(n,distancefile)
        plo.plot_MDS(plotfile, N, n, distances, Likelihoods, bestlike, Treelist, Pathtrees)
        plo.interpolate_grid(plotfile2, N, n, distances,Likelihoods, bestlike, StartTrees)

